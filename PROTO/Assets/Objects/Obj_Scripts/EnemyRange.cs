using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyRange : MonoBehaviour
{
    public GameObject User;
    public GameObject secondary_Obj;
    public GameObject projectile_Obj;

    private Obj_State obj_Data;
    private Obj_State secondary_Data;

    private bool userInRange = true;
    private bool can_Attack = true;

    private float range = 5f;
    private float distance;

    private void Start()
    {
        obj_Data = GetComponent<Obj_State>();
        secondary_Data = secondary_Obj.GetComponent<Obj_State>();
    }

    private void Update()
    {
        distance = Vector3.Distance(transform.position, User.transform.position);
        if (distance < range && can_Attack)
        {
            shoot();
        }
    }

    void shoot()
    {
        Vector3 targetting_Location = transform.position + ((User.transform.position) - transform.position).normalized * obj_Data.Reach; // Finds the direction of the mouse and the position in the line between the mouse position and the player within the interaction distance.
        targetting_Location.z = 0;
        GameObject new_Projectile_Obj = Instantiate(projectile_Obj, transform.position, Quaternion.identity);
        Obj_State projectile_Data = new_Projectile_Obj.GetComponent<Obj_State>();
        new_Projectile_Obj.GetComponent<Rigidbody2D>().AddRelativeForce(targetting_Location.normalized * projectile_Data.Speed, ForceMode2D.Impulse);
        StartCoroutine(AttackCooldown(obj_Data.melee_Cooldown));
    }


    IEnumerator AttackCooldown(float length)
    {
        yield return new WaitForSeconds(length);
        can_Attack = true;
        Debug.Log("can attack again");
    }
}
