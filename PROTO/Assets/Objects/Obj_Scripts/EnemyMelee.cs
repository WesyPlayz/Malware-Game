using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyMelee : MonoBehaviour
{
    public GameObject User;
    public GameObject secondary_Obj;

    private Obj_State obj_Data;
    private Obj_State secondary_Data;


    Vector3 direction;
    Vector2 targetPos;

    private bool userInRange = true;
    private bool can_Attack = true;

    private float range = 5f;
    private float distance;

    private void Start()
    {
        obj_Data = GetComponent<Obj_State>();
        secondary_Data = secondary_Obj.GetComponent<Obj_State>();
    }

    private void Update()
    {
        distance = Vector3.Distance(transform.position, User.transform.position);
        

        if (distance < range)
        {
            if (userInRange)
            {
                Vector3 targetting_Location = transform.position + ((User.transform.position) - transform.position).normalized * obj_Data.Reach; // Finds the direction of the mouse and the position in the line between the mouse position and the player within the interaction distance.
                targetting_Location.z = 0;
                secondary_Obj.transform.position = Vector3.MoveTowards(secondary_Obj.transform.position, targetting_Location, secondary_Data.Speed); // positions the detection zone based on the calculated position above.

                if (secondary_Data.collided_Entity != null && can_Attack)
                {
                    can_Attack = false;
                    attack();
                    StartCoroutine(AttackCooldown(obj_Data.melee_Cooldown));
                }
            }
        }
    }

    void attack()
    {
        
         //sound effects go here
        if (secondary_Data.collided_Entity.name == "User")
        {
            /*
            secondary_Data.collided_Entity.GetComponent<UserHandler>().damaged_Particle.GetComponent<ParticleSystem>().Play();
            secondary_Data.collided_Entity.GetComponent<UserHandler>().damaged_Sound.Play();
            */
        }
        

        Obj_State entity_Data = secondary_Data.collided_Entity.GetComponent<Obj_State>();
        entity_Data.Health = Mathf.Max(entity_Data.Health - obj_Data.Damage, 0); // subtracts the damage amount to health, and doesn't allow health to go below 0 if it does.
    }

    IEnumerator AttackCooldown(float length)
    {
        yield return new WaitForSeconds(length);
        can_Attack = true;
    }
}
