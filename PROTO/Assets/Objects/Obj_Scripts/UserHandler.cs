using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using static Utilities.KeyBinds;
using static Utilities.Collision;
using static Utilities.Generic;

public class UserHandler : MonoBehaviour
{
    // Object State Variables:
    public GameObject secondary_Obj;
    public GameObject projectile_Obj;

    private Obj_State obj_Data;
    private Obj_State secondary_Data;

    private Rigidbody2D obj_Physics;

    // Dashing Variables:
    private bool can_Dash = true;

    private bool is_vDashing;
    private bool is_hDashing;

    // Jumping Variables:
    private bool is_Jumping;

    // Jumping Variables:
    private bool can_Attack = true;

    // Collision Variables:
    private bool on_Floor;
    private bool on_Wall;

    // Initiate State:
    void Start()
    {
        obj_Data = GetComponent<Obj_State>();
        secondary_Data = secondary_Obj.GetComponent<Obj_State>();

        obj_Physics = GetComponent<Rigidbody2D>();
    }

    // User Input System:
    void Update()
    {
        // Movement System:
        if (can_Dash && Input.GetKey(KeyCode.LeftShift)) // Dash System:
        {
            Vector2 direction = Vector2.zero; // Sets the default dash direction variable.
            if (Input.GetKeyDown(KeyCode.S)) // Downward dashing:
            {
                direction = Vector2.down;
                is_vDashing = true;
                StartCoroutine(DashCooldown());
            }
            else if (Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.D)) // Horizontal dashing:
            {
                direction = Input.GetKeyDown(KeyCode.A) ? Vector2.left : Vector2.right; // finds whether your dashing right or left.
                is_hDashing = true;
            }
            if (is_vDashing || is_hDashing)
            {
                LinearJump(direction, obj_Data.dash_Force, gameObject); // Adds an impulse of force in the direction given.
                can_Dash = false;
                StartCoroutine(DashCooldown());
            }
        }
        else if (!(is_vDashing || is_hDashing) && Input.GetAxis("Horizontal") != 0) // Doesn't allow movement when dashing (kinda like a fatigue system)
            obj_Physics.velocity = new Vector2(Input.GetAxis("Horizontal") * obj_Data.Speed, obj_Physics.velocity.y);

        if (on_Wall && Input.GetKey(KeyCode.W)) // Climbing System:
            obj_Physics.velocity = new Vector2(obj_Physics.velocity.x, obj_Data.Speed / 2);
        else if (!is_Jumping) // Jumping System
        {
            if (Input.GetKeyDown(KeyCode.Space) && obj_Data.jumps_Occurred != obj_Data.max_Jumps)
            {
                is_Jumping = nonLinearJump(on_Floor, obj_Data.jump_Force, gameObject);
                StartCoroutine(JumpCooldown());
            }
        }

        // Attacking System:
        if (can_Attack)
        {
            if (secondary_Data.collided_Entity != null && Input.GetKeyDown(KeyCode.Mouse0))
            {
                can_Attack = false;
                MeleeAttack();
                StartCoroutine(AttackCooldown(obj_Data.melee_Cooldown));
            }
            else if (Input.GetKeyDown(KeyCode.Mouse1))
            {
                can_Attack = false;
                RangedAttack();
            }
        }

        // Detection System:
        Vector3 targetting_Location = transform.position + (Camera.main.ScreenToWorldPoint(Input.mousePosition) - transform.position).normalized * obj_Data.Reach; // Finds the direction of the mouse and the position in the line between the mouse position and the player within the interaction distance.
        targetting_Location.z = 0;
        secondary_Obj.transform.position = Vector3.MoveTowards(secondary_Obj.transform.position, targetting_Location, secondary_Data.Speed); // positions the detection zone based on the calculated position above.
    }

    // Attacking System:
    void MeleeAttack()
    {
        Obj_State entity_Data = secondary_Data.collided_Entity.GetComponent<Obj_State>();
        entity_Data.Health = Mathf.Max(entity_Data.Health - obj_Data.Damage, 0); // subtracts the damage amount to health, and doesn't allow health to go below 0 if it does.

        obj_Data.Energy = Mathf.Min(obj_Data.Energy + 
            (entity_Data.Health <= 0 ? Random.Range(obj_Data.mix_Energy_Increase * 5, obj_Data.max_Energy_Increase * 2) : 
            Random.Range(obj_Data.mix_Energy_Increase, obj_Data.max_Energy_Increase)), obj_Data.max_Energy);
    }
    void RangedAttack()
    {
        GameObject new_Projectile_Obj = Instantiate(projectile_Obj, transform);
        Obj_State projectile_Data = new_Projectile_Obj.GetComponent<Obj_State>();
        StartCoroutine(AttackCooldown(projectile_Data.range_Cooldown));
        LinearJump(Camera.main.ScreenToWorldPoint(Input.mousePosition), projectile_Data.Speed, new_Projectile_Obj);
        obj_Data.Energy = Mathf.Max(obj_Data.Energy - obj_Data.energy_Cost, 0);
    }

    // Collision System:
    void OnCollisionEnter2D(Collision2D sender)
    {
        GameObject current_Obj = sender.gameObject;
        obj_Data.total_Collisions++;
        if (current_Obj.layer == LayerMask.NameToLayer("Destructable"))
        {
            bool destroy =
                is_vDashing ? FindSurfaceType("Floor", sender) : // Check for Vertical Dashing
                is_hDashing ? FindSurfaceType("Wall", sender) : // Check for Horizontal Dashing
                false; // Return false if neither
            if (destroy)
            {
                obj_Data.total_Collisions--;
                Destroy(current_Obj);
                is_vDashing = is_hDashing = false;
                return;
            }
            else
            {
                bool foundFloor = FindSurfaceType("Floor", sender, gameObject);
                if (foundFloor) // Resets jump counter when touching floor:
                {
                    on_Floor = true;
                    obj_Data.jumps_Occurred = obj_Data.jumps_Occurred > 0 ? 0 : obj_Data.jumps_Occurred;
                }
            }
        }
        else if (current_Obj.layer == LayerMask.NameToLayer("Terrain"))
        {
            bool foundFloor = FindSurfaceType("Floor", sender, gameObject);
            bool foundWall = FindSurfaceType("Wall", sender, gameObject);
            if (foundFloor)
            {
                on_Floor = true;
                obj_Data.jumps_Occurred = obj_Data.jumps_Occurred > 0 ? 0 : obj_Data.jumps_Occurred;
            }
            else if (foundWall)
                on_Wall = true;
        }
        obj_Data.collided_Obj = current_Obj;
    }
    void OnCollisionExit2D(Collision2D sender)
    {
        if (--obj_Data.total_Collisions == 0)
            obj_Data.collided_Obj = null;
        on_Floor = // Changes on_Floor if or if not still on floor:
            obj_Data.collided_Obj == null ? false :
            !obj_Data.collided_Obj.CompareTag("Floor") && sender.gameObject.CompareTag("Floor") ? false :
            on_Floor;
        on_Wall = // Changes on_Wall if or if not still on wall:
            obj_Data.collided_Obj == null ? false :
            !obj_Data.collided_Obj.CompareTag("Wall") && sender.gameObject.CompareTag("Wall") ? false :
            on_Wall;
    }

    // Cooldown Systems:
    IEnumerator DashCooldown()
    {
        yield return new WaitForSeconds(obj_Data.dash_Cooldown / 2);
        is_vDashing = is_hDashing = false;
        yield return new WaitForSeconds(obj_Data.dash_Cooldown / 2);
        can_Dash = true;
    }
    IEnumerator JumpCooldown()
    {
        yield return new WaitForSeconds(obj_Data.jump_Cooldown);
        obj_Data.jumps_Occurred++;
        is_Jumping = false;
    }
    IEnumerator AttackCooldown(float length)
    {
        yield return new WaitForSeconds(length);
        can_Attack = true;
    }
}