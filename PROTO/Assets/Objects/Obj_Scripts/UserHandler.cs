using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using static Utilities.KeyBinds;
using static Utilities.Collision;
using static Utilities.Generic;

public class UserHandler : MonoBehaviour
{
    // Object State Variables:
    public AudioSource projectile_Sound;

    public GameObject secondary_Obj;
    public GameObject Cursor;
    public GameObject projectile_Obj;

    private Obj_State obj_Data;
    private Obj_State secondary_Data;

    private Rigidbody2D obj_Physics;
    private Transform obj_Transform;

    // Dashing Variables:
    private bool can_Dash = true;

    private bool is_vDashing;
    private bool is_hDashing;

    // Jumping Variables:
    private bool is_Jumping;

    // Jumping Variables:
    private bool can_Attack = true;

    Vector2 dirction;
    Vector3 targetting_Location;

    // Collision Variables:
    public bool on_Floor;
    public bool on_Wall;

    // Initiate State:
    void Start()
    {
        obj_Data = GetComponent<Obj_State>();
        secondary_Data = secondary_Obj.GetComponent<Obj_State>();

        obj_Physics = GetComponent<Rigidbody2D>();
        obj_Transform = GetComponent<Transform>();
    }

    // User Input System:
    void Update()
    {
        if (on_Floor)
            obj_Physics.AddRelativeForce(Vector2.down * obj_Data.grivity);

        // Movement System:
        if (can_Dash && Input.GetButton("Fire3")) // Dash System:
        {
            Vector2 direction = Vector2.zero; // Sets the default dash direction variable.
            if (Input.GetAxis("Vertical") < 0) // Downward dashing:
            {
                direction = Vector2.down;
                is_vDashing = true;
                StartCoroutine(DashCooldown());
            }
            else if (Input.GetAxis("Horizontal") < 0 || Input.GetAxis("Horizontal") > 0) // Horizontal dashing:
            {
                direction = (Input.GetAxis("Horizontal") < 0) ? Vector2.left : Vector2.right; // finds whether your dashing right or left.
                is_hDashing = true;
            }
            if (is_vDashing || is_hDashing)
            {
                LinearJump(direction, obj_Data.dash_Force, gameObject); // Adds an impulse of force in the direction given.
                can_Dash = false;
                StartCoroutine(DashCooldown());
            }
        }
        else if (!(is_vDashing || is_hDashing) && !(on_Wall && Input.GetAxis("Vertical") > 0) && Input.GetAxis("Horizontal") != 0) // Doesn't allow movement when dashing (kinda like a fatigue system) (on_Floor || on_Wall)
            obj_Physics.velocity = new Vector2(Input.GetAxis("Horizontal") * obj_Data.Speed, obj_Physics.velocity.y);

        if (on_Wall && Input.GetAxis("Vertical") > 0) // Climbing System:
            obj_Physics.AddRelativeForce(Vector2.up * (-Physics.gravity / 6));
        else if (!is_Jumping) // Jumping System
        {
            if (Input.GetButtonDown("Jump") && obj_Data.jumps_Occurred != obj_Data.max_Jumps)
            {
                is_Jumping = nonLinearJump(on_Floor, obj_Data.jump_Force, gameObject);
                StartCoroutine(JumpCooldown());
            }
        }

        // Attacking System:
        if (can_Attack)
        {
            if (secondary_Data.collided_Entity != null && Input.GetAxis("RT") != 0)
            {
                Debug.Log("trigger pulled");
                can_Attack = false;
                MeleeAttack();
                StartCoroutine(AttackCooldown(obj_Data.melee_Cooldown));
            }
            else if (Input.GetAxis("LT") != 0 && obj_Data.Energy >= obj_Data.energy_Cost)
            {
                can_Attack = false;
                RangedAttack();
                StartCoroutine(AttackCooldown(obj_Data.range_Cooldown));
            }
        }

        // Detection System:
        Vector3 targetting_Location = transform.position + ((Cursor.transform.position) - transform.position).normalized * obj_Data.Reach; // Finds the direction of the mouse and the position in the line between the mouse position and the player within the interaction distance.
        targetting_Location.z = 0;
        secondary_Obj.transform.position = Vector3.MoveTowards(secondary_Obj.transform.position, targetting_Location, secondary_Data.Speed); // positions the detection zone based on the calculated position above.
    }

    // Attacking System:
    void MeleeAttack()
    {
        if (secondary_Data.collided_Entity.name == "Enemy")
        {
            secondary_Data.collided_Entity.GetComponent<EnemyHandler>().damaged_Particle.GetComponent<ParticleSystem>().Play();
            secondary_Data.collided_Entity.GetComponent<EnemyHandler>().damaged_Sound.Play();
        }

        Obj_State entity_Data = secondary_Data.collided_Entity.GetComponent<Obj_State>();
        entity_Data.Health = Mathf.Max(entity_Data.Health - obj_Data.Damage, 0); // subtracts the damage amount to health, and doesn't allow health to go below 0 if it does.

        obj_Data.Energy = Mathf.Min(obj_Data.Energy + 
            (entity_Data.Health <= 0 ? Random.Range(obj_Data.mix_Energy_Increase * 5, obj_Data.max_Energy_Increase * 2) : 
            Random.Range(obj_Data.mix_Energy_Increase, obj_Data.max_Energy_Increase)), obj_Data.max_Energy);
    }
    void RangedAttack()
    {
        print("YAYAUGD");
        projectile_Sound.Play();
        GameObject new_Projectile_Obj = Instantiate(projectile_Obj, transform.position, Quaternion.identity);
        Obj_State projectile_Data = new_Projectile_Obj.GetComponent<Obj_State>();
        Vector2 direction = (secondary_Obj.transform.position - obj_Transform.transform.position);
        new_Projectile_Obj.GetComponent<Rigidbody2D>().AddRelativeForce(direction.normalized * projectile_Data.Speed, ForceMode2D.Impulse);
        obj_Data.Energy = Mathf.Max(obj_Data.Energy - obj_Data.energy_Cost, 0);
    }

    // Collision System:
    void OnCollisionEnter2D(Collision2D sender)
    {
        GameObject current_Obj = sender.gameObject;
        obj_Data.total_Collisions++;
        if (current_Obj.layer == LayerMask.NameToLayer("Destructable"))
        {
            bool destroy =
                is_vDashing ? FindSurfaceType("Floor", sender) : // Check for Vertical Dashing
                is_hDashing ? FindSurfaceType("Wall", sender) : // Check for Horizontal Dashing
                false; // Return false if neither
            if (destroy)
            {
                obj_Data.total_Collisions--;
                Destroy(current_Obj);
                is_vDashing = is_hDashing = false;
                return;
            }
            else
            {
                bool foundFloor = FindSurfaceType("Floor", sender, gameObject);
                if (foundFloor) // Resets jump counter when touching floor:
                {
                    on_Floor = true;
                    obj_Data.jumps_Occurred = obj_Data.jumps_Occurred > 0 ? 0 : obj_Data.jumps_Occurred;
                    obj_Data.collided_Obj = current_Obj;
                }
            }
        }
        else if (current_Obj.layer == LayerMask.NameToLayer("Terrain"))
        {
            bool foundFloor = FindSurfaceType("Floor", sender, gameObject);
            bool foundWall = FindSurfaceType("Wall", sender, gameObject);
            if (foundFloor)
            {
                on_Floor = true;
                obj_Data.jumps_Occurred = obj_Data.jumps_Occurred > 0 ? 0 : obj_Data.jumps_Occurred;
                obj_Data.collided_Obj = current_Obj;
            }
            else if (foundWall)
            {
                on_Wall = true;
                obj_Data.collided_Obj = current_Obj;
            }
        }
        else
            obj_Data.collided_Obj = null;
    }
    void OnCollisionExit2D(Collision2D sender)
    {
        if (--obj_Data.total_Collisions == 0)
            obj_Data.collided_Obj = null;
        on_Floor = // Changes on_Floor if or if not still on floor:
            obj_Data.collided_Obj == null ? false :
            !obj_Data.collided_Obj.CompareTag("Floor") && sender.gameObject.CompareTag("Floor") ? false :
            on_Floor;
        on_Wall = // Changes on_Wall if or if not still on wall:
            obj_Data.collided_Obj == null ? false :
            !obj_Data.collided_Obj.CompareTag("Wall") && sender.gameObject.CompareTag("Wall") ? false :
            on_Wall;
    }

    // Cooldown Systems:
    IEnumerator DashCooldown()
    {
        yield return new WaitForSeconds(obj_Data.dash_Cooldown / 2);
        is_vDashing = is_hDashing = false;
        yield return new WaitForSeconds(obj_Data.dash_Cooldown / 2);
        can_Dash = true;
    }
    IEnumerator JumpCooldown()
    {
        yield return new WaitForSeconds(obj_Data.jump_Cooldown);
        obj_Data.jumps_Occurred++;
        is_Jumping = false;
    }
    IEnumerator AttackCooldown(float length)
    {
        yield return new WaitForSeconds(length);
        can_Attack = true;
        Debug.Log("can attack again");
    }
}